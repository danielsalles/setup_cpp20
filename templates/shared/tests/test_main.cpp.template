#include <catch2/catch_test_macros.hpp>
#include <catch2/catch_template_test_macros.hpp>
#include <catch2/generators/catch_generators.hpp>

{% if project_type == "library" -%}
#include <library.hpp>
{% endif -%}

#include <vector>
#include <string>
#include <ranges>
#include <concepts>
#include <optional>
#include <span>
#include <numeric>
#include <chrono>
#include <iterator>

// Test C++20 concepts
template<typename T>
concept Numeric = std::integral<T> || std::floating_point<T>;

template<Numeric T>
constexpr T square(T value) noexcept {
    return value * value;
}

template<Numeric T>
constexpr T add(T a, T b) noexcept {
    return a + b;
}

// Basic math operations tests
TEST_CASE("Basic math operations work correctly", "[math]") {
    SECTION("Addition") {
        REQUIRE(add(2, 3) == 5);
        REQUIRE(add(-1, 1) == 0);
        REQUIRE(add(0, 0) == 0);
    }
    
    SECTION("Square function") {
        REQUIRE(square(4) == 16);
        REQUIRE(square(-3) == 9);
        REQUIRE(square(0) == 0);
        
        // Test with floating point
        REQUIRE(square(2.5) == 6.25);
    }
}

// C++20 concepts testing
TEST_CASE("C++20 concepts work correctly", "[concepts][cpp20]") {
    SECTION("Numeric concept with integers") {
        static_assert(Numeric<int>);
        static_assert(Numeric<long>);
        static_assert(Numeric<short>);
        
        REQUIRE(square(5) == 25);
        REQUIRE(add(10, 20) == 30);
    }
    
    SECTION("Numeric concept with floating point") {
        static_assert(Numeric<float>);
        static_assert(Numeric<double>);
        
        REQUIRE(square(3.0f) == 9.0f);
        REQUIRE(add(1.5, 2.5) == 4.0);
    }
    
    SECTION("Non-numeric types are rejected") {
        static_assert(!Numeric<std::string>);
        static_assert(!Numeric<std::vector<int>>);
    }
}

// C++20 ranges testing
TEST_CASE("C++20 ranges work correctly", "[ranges][cpp20]") {
    std::vector<int> numbers{1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    
    SECTION("Filter even numbers") {
        auto even_numbers = numbers 
            | std::views::filter([](int n) { return n % 2 == 0; });
        
        std::vector<int> result(even_numbers.begin(), even_numbers.end());
        std::vector<int> expected{2, 4, 6, 8, 10};
        
        REQUIRE(result == expected);
    }
    
    SECTION("Transform and filter") {
        auto squared_evens = numbers 
            | std::views::filter([](int n) { return n % 2 == 0; })
            | std::views::transform(square<int>);
        
        std::vector<int> result(squared_evens.begin(), squared_evens.end());
        std::vector<int> expected{4, 16, 36, 64, 100};
        
        REQUIRE(result == expected);
    }
    
    SECTION("Take first N elements") {
        auto first_three = numbers | std::views::take(3);
        
        std::vector<int> result(first_three.begin(), first_three.end());
        std::vector<int> expected{1, 2, 3};
        
        REQUIRE(result == expected);
    }
}

// std::optional testing
TEST_CASE("std::optional error handling", "[optional][cpp20]") {
    auto safe_divide = [](double a, double b) -> std::optional<double> {
        if (b == 0.0) {
            return std::nullopt;
        }
        return a / b;
    };
    
    SECTION("Valid division") {
        auto result = safe_divide(10.0, 2.0);
        REQUIRE(result.has_value());
        REQUIRE(result.value() == 5.0);
    }
    
    SECTION("Division by zero") {
        auto result = safe_divide(5.0, 0.0);
        REQUIRE_FALSE(result.has_value());
    }
}

// std::span testing
TEST_CASE("std::span functionality", "[span][cpp20]") {
    std::vector<int> data{1, 2, 3, 4, 5};
    
    SECTION("Span from vector") {
        std::span<int> span_data(data);
        
        REQUIRE(span_data.size() == 5);
        REQUIRE(span_data[0] == 1);
        REQUIRE(span_data[4] == 5);
    }
    
    SECTION("Subspan") {
        std::span<int> span_data(data);
        auto sub = span_data.subspan(1, 3);
        
        REQUIRE(sub.size() == 3);
        REQUIRE(sub[0] == 2);
        REQUIRE(sub[2] == 4);
    }
    
    SECTION("Modify through span") {
        std::span<int> span_data(data);
        span_data[0] = 99;
        
        REQUIRE(data[0] == 99);  // Original vector modified
        REQUIRE(span_data[0] == 99);
    }
}

{% if project_type == "library" -%}
// Library-specific tests
TEST_CASE("{{ project_name }} library functionality", "[{{ project_name | lower }}][library]") {
    using namespace {{ project_name | lower }};
    
    SECTION("Version information") {
        REQUIRE_FALSE(Version::full.empty());
        REQUIRE(Version::major >= 1);
        REQUIRE(Version::minor >= 0);
        REQUIRE(Version::patch >= 0);
    }
    
    SECTION("Error handling") {
        REQUIRE(to_string(Error::None) == "No error");
        REQUIRE(to_string(Error::InvalidInput) == "Invalid input");
        REQUIRE_FALSE(to_string(Error::InternalError).empty());
    }
    
    SECTION("Utility functions") {
        // Test library-specific functionality here
        // Add more tests based on your library's API
        INFO("Add tests for your library's specific functionality");
        REQUIRE(true); // Placeholder
    }
}
{% endif -%}

// Parameterized tests using generators
TEST_CASE("Parameterized tests with generators", "[generators]") {
    auto value = GENERATE(1, 2, 3, 4, 5);
    
    SECTION("Square of positive numbers") {
        auto result = square(value);
        REQUIRE(result > 0);
        REQUIRE(result == value * value);
    }
}

// Template tests
TEMPLATE_TEST_CASE("Template tests for numeric types", "[template][numeric]", 
                   int, long, float, double) {
    TestType value = static_cast<TestType>(4);
    
    SECTION("Square function works with different types") {
        auto result = square(value);
        REQUIRE(result == static_cast<TestType>(16));
    }
    
    SECTION("Addition function works with different types") {
        TestType a = static_cast<TestType>(2);
        TestType b = static_cast<TestType>(3);
        auto result = add(a, b);
        REQUIRE(result == static_cast<TestType>(5));
    }
}

// Performance/benchmark placeholder
TEST_CASE("Performance tests", "[performance][.]") {
    // Hidden test (tagged with .) - won't run by default
    // Use for performance/benchmark tests
    
    SECTION("Large vector processing") {
        std::vector<int> large_data(1000000);
        std::iota(large_data.begin(), large_data.end(), 1);
        
        auto start = std::chrono::high_resolution_clock::now();
        
        auto processed = large_data 
            | std::views::filter([](int n) { return n % 2 == 0; })
            | std::views::transform(square<int>)
            | std::views::take(100);
        
        // Convert ranges to vector properly
        std::vector<int> result;
        std::ranges::copy(processed, std::back_inserter(result));
        
        auto end = std::chrono::high_resolution_clock::now();
        auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end - start);
        
        REQUIRE(result.size() == 100);
        REQUIRE(result[0] == 4); // square(2)
        
        INFO("Processing took " << duration.count() << "ms");
    }
} 